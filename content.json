{"meta":{"title":"黄志聪のブログ","subtitle":"从入门到放弃治疗","description":"走自己的路，让别人有路可走","author":"hzcong","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-13T12:43:27.308Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[黄志聪のブログ] 与&nbsp; huangzhicong&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-10T08:23:47.353Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-10T08:23:47.353Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-10T08:23:47.354Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-10T08:23:47.354Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-10T08:23:47.354Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-10T08:23:47.355Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-10T08:23:47.355Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-10T08:23:47.357Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-10T08:23:47.356Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-10T08:23:47.358Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-10T08:23:47.359Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"前后端联调那些事","slug":"前后端联调神器","date":"2019-10-03T07:14:00.000Z","updated":"2019-10-13T11:28:45.582Z","comments":true,"path":"2019/10/03/前后端联调神器/","link":"","permalink":"/2019/10/03/前后端联调神器/","excerpt":"","text":"序言前后端分离，是当今很流行的开发模式，后端只负责数据的提供和计算，而前端则负责拿到数据，组织数据并展现，前后端仅仅通过接口来联调。结构清晰，关注点分离，前后端相对独立并松耦合，这种方式使得前后端都更加专注。 但是这种想法依然还是很理想化，前后端集成往往还是一个很头痛的问题。比如在最后需要集成的时候，我们才发现最开始商量好的数据结构发生了变化，而且这种变化往往是在所难免的，这样就会增加大量的集成时间。 谁来买单谈到了前后端分离，那么在所难免，会遇到一些集成的问题：一拨人在全心全意的进行前端开发，另一拨人在心无旁骛的做后端开发，那么谁应该为集成买单呢？在现在这个持续集成、持续交付的年代里，我们应该如何去保证双方不会分道扬镳、越走越远呢？ 所以，迫在眉睫的事情，就是接口的定义与规范。双方就API相关内容，URL、参数、类型、请求方法等达成一致。一般以接口文档的方式，但是这份文档并不是创建后就不能修改的，如果一开始没有设计好，反而很有可能会频繁的修改，这个时候，要让前后端能实时追踪最新的API就成了一个难题。 接口不规范，同事两行泪前后端分离的时代，接口设计是重中之重，接口规范，关乎着团队协作、项目维护的时间成本。而RESTful风格的API与前后端分离开发正是天造地设的一对，它能有效的使接口规范起来。 什么是RESTful？RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。RESTful架构，目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 这里简单介绍几点，大家可以感受一下。 对于资源的操作类型应该是通过http动词表示。GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 HTTP Method分别对于资源的CURD操作GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 保证 POST，PUT，DELETE，PATCH，GET 操作幂等性。 …… 总结一点，优秀的RESTful接口设计，能够根据请求的路径及请求方法就能看出这个接口主要是对具体某个资源进行什么方法的操作以及返回数据的规则等等。 别再写开发文档了接口文档能有效的降低团队沟通成本，但维护接口文档的成本也相应更大。因需求变更等原因，免不了要修改后台代码，可能是增删参数，可能是修改方法，如果接口文档忘记更新了，前端开发时，前端开发时，看着错误的文档开发，发现接口动不动就500、404、400，然后就噼里啪啦的各种问，结果才发现，原来罪魁祸首是忘记更新开发文档。而且，多次修改开发文档，自己也不知道哪一个是最新的了。此时，你会问可以不写开发文档还能保证接口的实时性与准确性吗？答案是可以的，为解决开发人员的痛点，swagger UI应运而生。 Swagger到底是什么玩意？Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。 作用：接口的文档在线自动生成、接口测试。 说白了就是，实时更新接口文档，提供在线的接口测试（可以不用再使用postman测试了，这个功能还是非常便利的，并且请求参数的格式都为你生成好了） SpringBoot整合Swagger UITalk is cheap，这里以SpringBoot整合Swagger UI作为例子。 添加maven依赖&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; Swagger2配置配置swagger的过程也是比较简单，只需要一个配置类. import io.swagger.annotations.ApiOperation; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.ApiKey; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.List; import static com.google.common.collect.Lists.newArrayList; @Configuration @EnableSwagger2 public class SwaggerConfig implements WebMvcConfigurer { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //加了ApiOperation注解的类，才生成接口文档 .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) //包下的类，才生成接口文档 //.apis(RequestHandlerSelectors.basePackage(&quot;com.xxxx.controller&quot;)) .paths(PathSelectors.any()) .build() .securitySchemes(security()); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;XXX项目&quot;) .description(&quot;接口文档&quot;) .termsOfServiceUrl(&quot;https://www.xxx.com&quot;) .version(&quot;2.0.0&quot;) .build(); } // 配置token请求头 private List&lt;ApiKey&gt; security() { return newArrayList( new ApiKey(&quot;token&quot;, &quot;token&quot;, &quot;header&quot;) ); } } 这里提供一个配置类，首先通过@EnableSwagger2注解启用Swagger2，然后配置一个Docket Bean，这个Bean中，配置映射路径和要扫描的接口的位置，在apiInfo中，主要配置一下Swagger2文档网站的信息，最后是配置了接口的安全验证，如需要token凭证等等。 添加注解swagger是根据注解扫描生成文档的，所以熟悉这些注解很重要 @Api：用在请求的类上，表示对类的说明 tags=&quot;说明该类的作用，可以在UI界面上看到的注解&quot; value=&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot; @ApiOperation：用在请求的方法上，说明方法的用途、作用 value=&quot;说明方法的用途、作用&quot; notes=&quot;方法的备注说明&quot; @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header --&gt; 请求参数的获取：@RequestHeader · query --&gt; 请求参数的获取：@RequestParam · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot; defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如&quot;请求参数没填好&quot; response：抛出异常的类 @ApiModel：用于响应类上，表示一个返回响应数据的信息 （这种一般用在post创建的时候，使用@RequestBody这样的场景， 请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：用在属性上，描述响应类的属性 进行测试点击右上角 Authorize 可为接口添加凭证，如配置类中配置的token 点击右边的参数会自动添加进去。再点击Try it out! 按钮就可以进行请求了。 结语，一个人可以走的很快，一群人才能走的更远，团队合作很重要。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"前后端协作","slug":"前后端协作","permalink":"/tags/前后端协作/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"封装微信小程序网络请求","slug":"封装微信小程序网络请求","date":"2019-10-02T19:29:00.000Z","updated":"2019-10-13T11:48:44.614Z","comments":true,"path":"2019/10/03/封装微信小程序网络请求/","link":"","permalink":"/2019/10/03/封装微信小程序网络请求/","excerpt":"","text":"在微信小程序的开发中，网络请求是使用的最频繁的，觉得小程序的wx.request写在代码里面实在不好看，显得冗余。要使代码更优雅一些，于是想个办法封装一下。 封装wx.request 打开小程序的工程目录，新建一个utils文件夹，用于存放我们的工具类。 在utils文件夹下新建一个util.js文件，用于封装我们的wx.request,以及其他工具函数，代码如下： const app = getApp(); /** * 封装微信的request */ function request(url, data = {}, method = &quot;GET&quot;) { return new Promise(function(resolve, reject) { wx.request({ url: url, data: data, method: method, header: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;token&#39;: wx.getStorageSync(&#39;token&#39;) }, success: function(res) { switch (res.data.code) { // 状态码为0，则返回数据（这里以自定义的code为0，意为成功） case 0: resolve(res.data); break; //状态码为401，token失效 case 401: // 清除登录相关内容 try { wx.removeStorageSync(&#39;userInfo&#39;); wx.removeStorageSync(&#39;token&#39;); //登录态设置false app.globalData.hasLogin = false; } catch (e) { // Do something when catch error } // 切换到登录页面 wx.navigateTo({ url: &#39;/pages/auth/login/login&#39; }); break; // 其他状态码，默认返回错误提示 default: showErrorToast(res.data.msg); } }, fail: function(err) { showErrorToast(err.errMsg); reject(err); } }) }); } function showErrorToast(msg) { wx.hideLoading(); wx.showModal({ title: &#39;提示&#39;, content: msg, showCancel: false }) } module.exports = { request, showErrorToast } 如何使用，代码如下： //导入js文件，自己注意路径 const util = require(&#39;../../../utils/util.js&#39;); //请求，只需传入api地址，参数，请求方法 util.request(&#39;https://xxxx&#39;, params, &#39;POST&#39;) .then(function(res) { // res就是请求成功的返回数据 console.log(res); }); 统一API，分而治之 也许你会说，不就是把wx.request封装了一下嘛。当然，我们还可以更进一步，因为项目中的api大部分都是可以复用的，我们可以把需要网络请求的API统一管理起来（所以，有一份漂亮的API文档很重要，比如后台是用Java的，可以使用swagger等自动生成接口文档）。 我们可以在小程序工程项目里面新建一个文件夹为config，在里面新建一个api.js文件。 api.js // 以下是业务服务器API地址 // 本机开发时使用 // const WxApiRoot = &#39;http://localhost:8080/xx/&#39;; // 局域网测试使用 // const WxApiRoot = &#39;http://192.168.2.174:8080/xx/&#39;; // 部署测试时使用 const WxApiRoot = &#39;http://xx.xx.xx.xx:8080/xx/&#39;; // 上线时使用 // const WxApiRoot = &#39;https://xxxxx.com/xx/&#39;; //这里只做简单例子 module.exports = { AuthLoginByWeixin: WxApiRoot + &#39;app/weixin/login&#39;, //微信登录 AuthLogout: WxApiRoot + &#39;auth/logout&#39;, //账号登出 }; 使用就更简单了，代码如下： //引入文件，路径根据自己项目路径修改 const util = require(&#39;../../../utils/util.js&#39;); const api = require(&#39;../../../config/api.js&#39;); util.request(api.xxx, params, &#39;POST&#39;) .then(function(res) { console.log(res); //请求后的操作 })； 代码似乎优雅了许多，请求失败也有错误提示，相对于开发或用户，体验会好很多。当然在非常复杂的系统，也可以再把api分类会更好一些，每个模块一个api文件，一旦需求多了，业务复杂了，分而治之总是个不错的办法。 结语，另外，我们也可以往更抽象的去考虑，把一些业务逻辑标准化，UI标准化，接口标准化，这样我们也许可以做一个只需设定一些规则，做简单配置就可以生成小程序或前后端的代码的工具，这个值得我们思考。","categories":[{"name":"wechat","slug":"wechat","permalink":"/categories/wechat/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"/tags/微信小程序/"}],"keywords":[{"name":"wechat","slug":"wechat","permalink":"/categories/wechat/"}]}]}